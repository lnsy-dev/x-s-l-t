var r={217:()=>{class r extends HTMLElement{connectedCallback(){this.processXmlAndXsl()}async processXmlAndXsl(){const r=this.getAttribute("xml-src"),e=this.getAttribute("xsl-src");if(r&&e)try{this.innerHTML="<p>Loading...</p>";const[t,s]=await Promise.all([this.fetchResource(r),this.fetchResource(e)]),o=new DOMParser,n=o.parseFromString(t,"application/xml"),a=o.parseFromString(s,"application/xml");if(this.hasParsingError(n))throw new Error("Error parsing XML document");if(this.hasParsingError(a))throw new Error("Error parsing XSL document");const i=await this.transformXml(n,a);this.innerHTML=i}catch(r){console.error("Error processing XML/XSL:",r),this.innerHTML=`<p style="color: red;">Error: ${r.message}</p>`}else this.innerHTML="<p>Both xml-src and xsl-src attributes are required</p>"}hasParsingError(r){return null!==r.querySelector("parsererror")}async transformXml(r,e){return new Promise((t,s)=>{try{const s=new XSLTProcessor;s.importStylesheet(e);const o=s.transformToFragment(r,document),n=document.createElement("div");n.appendChild(o.cloneNode(!0)),t(n.innerHTML)}catch(r){s(new Error(`XSLT transformation failed: ${r.message}`))}})}async fetchResource(r){try{const e=await fetch(r);if(!e.ok)throw new Error(`Failed to fetch ${r}: ${e.statusText}`);return await e.text()}catch(e){throw console.error(`Error fetching ${r}:`,e),e}}static get observedAttributes(){return["xml-src","xsl-src"]}async attributeChangedCallback(r,e,t){e!==t&&await this.processXmlAndXsl()}}customElements.define("x-l-s-t",r)}},e={};function t(s){var o=e[s];if(void 0!==o)return o.exports;var n=e[s]={exports:{}};return r[s](n,n.exports,t),n.exports}t.n=r=>{var e=r&&r.__esModule?()=>r.default:()=>r;return t.d(e,{a:e}),e},t.d=(r,e)=>{for(var s in e)t.o(e,s)&&!t.o(r,s)&&Object.defineProperty(r,s,{enumerable:!0,get:e[s]})},t.o=(r,e)=>Object.prototype.hasOwnProperty.call(r,e),t(217);